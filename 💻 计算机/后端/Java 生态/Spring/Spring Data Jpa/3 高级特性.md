
# â¤ï¸ åŸºæ¥å£ Repository
ä½¿ç”¨åŸºæ¥å£ Repository å¯ä»¥å¤ç”¨æ–¹æ³•å

- å®šä¹‰åŸºæ¥å£
```java
@NoRepositoryBean
public interface BaseRepository<T> {
    List<T> findAllByCustName(String name);
}
```
- ç»§æ‰¿
```java
public interface CustomerRepository extends BaseRepository<Customer>, JpaRepository<Customer, Long> {
}
```

# â¤ï¸ åˆ†é¡µ
<u>é™æ€æ–¹æ³•</u> ï¼š
- `PageRequest of(ç¬¬å‡ é¡µï¼Œä¸€é¡µçš„å¤§å°ï¼ŒSort æ’åºå¯¹è±¡)` é¡µç ä» 0 å¼€å§‹

```java
public interface CustomerRepository extends BaseRepository<Customer>, JpaRepository<Customer, Long> {
    Page<Customer> findAll(Pageable pageable);
}

@Test
public void test_findAll_pageable() {
	// å®šä¹‰åˆ†é¡µå‚æ•°
	PageRequest pageRequest = PageRequest.of(  
        1,  
        5,  
        Sort.by("no").descending()  
	);
	Page<Customer> all = customerRepository.findAll(pageRequest);

	JsonNode jsonNode = objectMapper.valueToTree(all);
	System.out.println(jsonNode.toString());
}
```

# â¤ï¸ æ˜ å°„å…³ç³»
å¦‚æœæ˜¯ä½¿ç”¨ Jpa Buddy ç”Ÿæˆçš„ JPQLï¼Œåˆ™ä¸æ”¯æŒæ˜ å°„å…³ç³»ï¼Œæ¯”å¦‚è¦æ‰§è¡Œä¸€ä¸ª updateï¼Œå¾ˆéº»çƒ¦ï¼Œè¿˜æ˜¯ä¹–ä¹–åœ°æ‰‹åŠ¨ç»´æŠ¤å§

## ğŸ’› å¤šå¯¹å¤š
- å¤šå¯¹å¤šä¸­ä¸€æ–¹ä¸ºç»´æŠ¤ç«¯ï¼Œä¸€æ–¹ä¸ºè¢«ç»´æŠ¤ç«¯ã€‚å…³ç³»çš„ç»‘å®šå’Œè§£é™¤éƒ½ç”±ç»´æŠ¤ç«¯æ¥å®Œæˆï¼Œå…³ç³»è¢«ç»´æŠ¤ç«¯ä¸èƒ½ç»‘å®šå…³ç³»
- å¦‚æœ Aï¼ŒB è¡¨å·²ç»ç»‘å®šäº†å¤šå¯¹å¤šçš„å…³ç³»ï¼Œé‚£ä¹ˆä¸èƒ½ç›´æ¥åˆ é™¤ä»è¡¨ï¼Œå¿…é¡»ç”±ä¸»è¡¨è§£é™¤å…³ç³»åï¼Œæ‰èƒ½åˆ é™¤ä»è¡¨ï¼›ä½†æ˜¯å¯ä»¥ç›´æ¥åˆ é™¤ä¸»è¡¨ï¼Œåˆ é™¤æ—¶ä¼šå…ˆè§£é™¤å…³ç³»ç„¶åå†åˆ é™¤

---

`@ManyToMany` 
- `cascade[]` è¯¥å±æ€§å®šä¹‰äº†çº§è”æ“ä½œçš„ç±»å‹ï¼Œå³åœ¨æ‰§è¡Œæ“ä½œæ—¶ï¼Œæ˜¯å¦å°†è¿™äº›æ“ä½œçº§è”åˆ°å…³è”çš„å®ä½“ä¸Š
	- `CascadeType.ALL` åŒ…æ‹¬ä»¥ä¸‹æ‰€æœ‰
	- `CascadeType.PERSIST` å½“æŒä¹…åŒ–æ“ä½œå‘ç”Ÿæ—¶ï¼Œçº§è”ä¿å­˜å…³è”çš„å®ä½“
	- `CascadeType.MERGE` å½“åˆå¹¶æ“ä½œå‘ç”Ÿæ—¶ï¼Œçº§è”æ›´æ–°å…³è”çš„å®ä½“
	- `CascadeType.REMOVE` å½“åˆ é™¤æ“ä½œå‘ç”Ÿæ—¶ï¼Œçº§è”åˆ é™¤å…³è”çš„å®ä½“
	- `CascadeType.REFRESH` å½“åˆ·æ–°æ“ä½œå‘ç”Ÿæ—¶ï¼Œçº§è”åˆ·æ–°å…³è”çš„å®ä½“
	- `CascadeType.DETACH` å½“åˆ†ç¦»æ“ä½œå‘ç”Ÿæ—¶ï¼Œçº§è”åˆ†ç¦»å…³è”çš„å®ä½“
- `fetch` æŒ‡å®šå…³è”å®ä½“çš„åŠ è½½ç­–ç•¥
	- `FetchType.LAZY` æ‡’åŠ è½½ï¼Œè¡¨ç¤ºåªæœ‰åœ¨å®é™…è®¿é—®è¯¥å…³è”æ—¶æ‰ä¼šä»æ•°æ®åº“åŠ è½½ç›¸å…³çš„å®ä½“
	- `FetchType.EAGER` ç«‹å³åŠ è½½ï¼Œè¡¨ç¤ºåœ¨åŠ è½½å½“å‰å®ä½“æ—¶ä¼šåŒæ—¶åŠ è½½å…³è”çš„å®ä½“
- `mappedBy` æ˜ å°„å…³ç³»çš„è¢«ç»´æŠ¤æ–¹ï¼Œéœ€è¦æ·»åŠ  mappedBy æ¥æŒ‡å®šç»´æŠ¤æ–¹

```java
@EqualsAndHashCode(exclude = {"authors"})
@Entity
public class Book implements Serializable {
    @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
    @JoinTable(name = "book_author",
            joinColumns = {@JoinColumn(name = "book_id", referencedColumnName = "id")},
            inverseJoinColumns = {@JoinColumn(name = "author_id", referencedColumnName = "id")})
    private Set<Author> authors;
}

@ToString(exclude = {"books"})
@EqualsAndHashCode(exclude = {"books"})  
@Entity  
public class Author implements Serializable {  
    @ManyToMany(mappedBy = "authors")  
    private Set<Book> books;  
}
```

> [!warning] `@ManyTOMany` æ—¶ Lombok ç”Ÿæˆçš„ @ToStringï¼Œ@EqualsAndHashCode ä¼šå¯¼è‡´ä¸¤ä¸ªé›†åˆå¾ªç¯æ¯”è¾ƒï¼Œé€ æˆå†…å­˜æº¢å‡ºï¼Œè¦ä¹ˆæ‰‹å†™ equals å’Œ hashcodeï¼Œè¦ä¹ˆæ’é™¤è¯¥å±æ€§
> ```java
> // ä¸»è¡¨
> @EqualsAndHashCode(exclude = {"authors"})
> public class Book {
>     @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
>     @JoinTable(name = "book_author",
>             joinColumns = {@JoinColumn(name = "book_id", referencedColumnName = "id")},
>             inverseJoinColumns = {@JoinColumn(name = "author_id", referencedColumnName = "id")})
>     private Set\<Author> authors;
> }
> 
> // ä»è¡¨
> @ToString(exclude = {"books"})
> @EqualsAndHashCode(exclude = {"books"})  
> public class Author {  
>     @ManyToMany(mappedBy = "authors")  
>     private Set\<Book> books;  
> }
> ```

# è§¦å‘å™¨
#é—®é¢˜ jpa æ€ä¹ˆå†™è§¦å‘å™¨

# å­˜å‚¨å¼•æ“


# æŸ¥è¯¢æ—¶æŠ“å–

> [!quote] æŠ“å–
> æŠ“å– æ˜¯ä»æ•°æ®åº“ä¸­è·å–å®ä½“ï¼ŒåŠå…¶å…³è”å±æ€§çš„æ•°æ®

<u>å®ä½“ç±»ä¸Š</u> ï¼š
-  `@NamedEntityGraph` åœ¨å®ä½“ç±»ä¸Šå®šä¹‰å®ä½“å›¾ï¼ŒæŒ‡å®šè¦æŠ“å–çš„å±æ€§
	- `name` æŒ‡å®šå®ä½“å›¾çš„åå­—
	- `attributeNodes` æŒ‡å®šæŠ“å–å“ªä¸ªå±æ€§

<u>ä»“å‚¨æ¥å£çš„æŸ¥è¯¢æ–¹æ³•ä¸Š</u> ï¼š
-  `@EntityGraph` åœ¨æŸ¥è¯¢æ–¹æ³•ä¸Šåº”ç”¨å®ä½“å›¾
    - `value`Â æŒ‡å®šå®ä½“å›¾çš„åå­—
    - `type`Â æŒ‡å®šæŠ“å–ç­–ç•¥
	    - FETCH ä»…æŠ“å–æŒ‡å®šçš„å±æ€§ï¼Œå…¶ä»–å±æ€§å°†ä½¿ç”¨é»˜è®¤çš„æ‡’åŠ è½½
	    - LOAD ä¸ä»…æŠ“å–æŒ‡å®šçš„å±æ€§ï¼Œè¿˜ä¼šæŠ“å–å…¶ä»–é»˜è®¤è®¾ç½®ä¸ºç«‹å³åŠ è½½çš„å±æ€§

## å¤ç”¨å®ä½“å›¾
**å¦‚æœæœ‰ä¸€ä¸ªå®ä½“å›¾éœ€è¦å¤ç”¨ï¼Œé‚£ä¹ˆå¯ä»¥å°†å…¶å®šä¹‰åœ¨ Entity ä¸Š**

- å®šä¹‰å‘½åå®ä½“å›¾
```java
@Entity
@NamedEntityGraph(name = "GroupInfo.detail", attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {
	@ManyToMany
	List<GroupMember> members = new ArrayList<GroupMember>();
	// é»˜è®¤æŠ“å–æ¨¡å¼æ˜¯æ‡’åŠ è½½ã€‚
}
```

- åœ¨æŸ¥è¯¢æ–¹æ³•ä¸­å¼•ç”¨å‘½åå®ä½“å›¾
```java
public interface GroupRepository extends CrudRepository<GroupInfo, String> {
  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);
}
```

## ä¸´æ—¶å®ä½“å›¾
**å¦‚æœæŸä¸ªå®ä½“å›¾ï¼Œåªåœ¨å½“å‰æŸ¥è¯¢æ–¹æ³•ä¸Šä½¿ç”¨ï¼Œé‚£å°±ç›´æ¥åœ¨å½“å‰æ–¹æ³•ä¸Šå®šä¹‰**

```java
public interface GroupRepository extends CrudRepository<GroupInfo, String> {
  @EntityGraph(attributePaths = { "members" })
  GroupInfo getByGroupName(String name);
}
```

# ä¸æ¨è - OneToMany
- `@OneToMany` 
	- `cascade` 
		- CascadeType.ALL - å¯¹ Many ç«¯çš„æ‰€æœ‰æŒä¹…åŒ–å®ä½“çš„æ“ä½œï¼Œéƒ½ä¼šè‡ªåŠ¨åº”ç”¨åˆ° One ç«¯
	- `orphanRemoval` 
		- true - One ç«¯åˆ é™¤äº†é›†åˆä¸­çš„ Many itemï¼Œé‚£åœ¨ Many ç«¯ï¼Œä¼šåˆ é™¤ item è®°å½•

```java
@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)  
@JoinColumn(name = "awardId")  // æŒ‡å®šAwardè¡¨ä¸­çš„å¤–é”®ä¸ºawardId  todo  
private List<Award> awards; // ç»‘å®šçš„å¥–å“é›†åˆ
```

# æ¨è - Convert å­˜ id é›†åˆ
```java
@Entity
public class RafflePool {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    @Column(columnDefinition = "TEXT")
    @Convert(converter = LongListToJsonConverter.class)
    private List<Long> awardIds; // ç»‘å®šçš„å¥–å“é›†åˆ
}

@Converter
public class LongListToJsonConverter implements AttributeConverter<List<Long>, String> {

    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * å®ä½“å±æ€§ --->>> æ•°æ®åº“åˆ—
     */
    @Override
    public String convertToDatabaseColumn(List<Long> longs) {
        try {
            return objectMapper.writeValueAsString(longs);
        } catch (Exception e) {
            throw new RuntimeException("Failed to convert list to JSON", e);
        }
    }

    /**
     * æ•°æ®åº“åˆ— --->>> å®ä½“å±æ€§
     */
    @Override
    public List<Long> convertToEntityAttribute(String dbData) {
        try {
            return objectMapper.readValue(dbData, new TypeReference<>() {
            });
        } catch (Exception e) {
            throw new RuntimeException("Failed to convert JSON to list", e);
        }
    }

}
```
