# ❤️ Java 基础
`==` 比较引用，`equal` 比较数值
- 对于整数类型的包装类 `Integer`、`Long` ，自动装箱会将小范围 `-128` - `127` 的数值缓存为同一实例
- 对于 `String` ，相同字面量会复用同一实例
- 而 StringBuffer、StringBuilder 没有重写 `equal` 方法，`equal` 与 `==` 作用相同，都是比较引用

## 集合
ArrayList 的初始容量为 10，扩容因子为 1.5

哈希原理 ：[[2 散列表]]

在非增强 for 中，使用 List 中的 remove 方法，跟据索引删除元素时，会有可能出现删除时的索引越界，~~因为，删除一个元素之后，其他元素的索引值会改变~~

<u>String、StringBuffer、StringBuilder</u> ：
- 性能
	- String 是不可变的、频繁修改时性能差
- 线程安全
	- String 针对内容是线程安全的，因为 String 的内容不可变。但 String 的引用是线程不安全的。
	- StringBuffer 是线程安全的，因为它的方法被 synchronized 关键字修饰，确保了多线程环境下的安全性
	- StringBuilder 是非线程安全的，因为它没有使用同步机制

<u>finalize 是什么</u> ：finalize 方法属于 Object 类，可以在对象被 GC 之前，执行一些清理操作，如关闭文件、释放内存 ……。**已经被废弃不推荐使用**

<u>创建对象有几种方法</u> ：
- new 出来
- 反射
- 如果类实现了 Cloneable 接口，可以调用 `clone()` 方法来复制一个现有的对象

# ❤️ 数据库
✅ 数据库事务 ：[[4-2 事务#❤️ 并发事务问题]]

✅ 数据库索引 ：[[5-1 索引，性能分析#索引分类]]

✅ 什么情况下索引会失效 ：模糊匹配时通配符在开头、用复杂的函数表达式查询、复合索引只出现一个

`Select count(*)` 和 `select count(1)` ：查询的结果一致，但是后者性能会较高

✅ 事务的四大特性 ACID
- **原子性** Atomicity：事务要么完全执行，要么完全不执行
- **一致性** Consistency：事务完成时，必须使所有数据都保持一致状态
- **隔离性** Isolation：保证事务在不受并发操作影响的独立环境下运行（DBMS 的隔离级别有很多，用户可以自行选择）
- **持久性** Durability：事务一旦 COMMIT / ROLLBACK，则数据永久改变

✅ Mysql 的 BIGINT 占用几个字节

✅ 为什么数据要用数据库存，不用文件

✅ sql 调优

✅ binlog 大小

# ❤️ Spring
Spring 中用到的设计模式 ：工厂模式、单例模式、模板方法模式、代理模式、策略模式、观察者模式

|    特性    |   `@Autowired`   |  `@Resource`   |      构造函数注入      |
| :------: | :--------------: | :------------: | :--------------: |
| **注入方式** |       基于类型       |      基于名称      |      通过构造函数      |
| **灵活性**  |        高         |       高        |        低         |
| **安全性**  |  依赖关系可能在运行时动态变化  | 依赖关系可能在运行时动态变化 | 依赖关系在对象创建时确定，更安全 |
| **适用场景** | 快速开发，依赖关系明确且类型唯一 | 需要精确指定依赖名称的场景  |  依赖关系必须且不可变的场景   |

<u>什么是 AOP，如何实现</u> ：
- AOP 是一种编程范式，用于将横切关注点从业务逻辑中分离出来。横切关注点是指那些与业务逻辑无关，但在应用程序中经常需要重复使用的功能，比如日志记录、安全控制、事务管理、性能监控等
- 如何实现
	- 引入依赖
	- 创建一个切面类并使用 @Aspect 注解标记
	- 使用 `@Around` 等通知注解标识切入点，调用 joinPoint 类中的各种方法控制源方法的执行

<u>Bean 的生命周期</u> ：
- 通过 注解 / XML 配置文件，获取到 Bean 的元数据，注册 Bean 的信息
- 当某个地方需要 Bean 时，IOC 容器会根据注册的元数据创建 Bean 实例
- IOC 容器会将 Bean 实例注入到需要的地方
- **初始化回调** ：
    - `@PostConstruct` 可以标记任何无参方法，这个方法会在依赖注入完成后被自动调用
- Bean 被完全初始化，可以被应用程序使用
- **销毁回调** ：
	- `@PreDestroy` 在 Bean 的生命周期结束之前，会调用
- Bean 的生命周期在 IOC 容器中结束，但是，Bean 实例是否从内存中消失还取决于 Java 的垃圾回收机制

<u>Spring 有哪些扩展接口</u> ：

# ❤️ ORM 框架
<u>sql 语句在配置文件中的 “# ”和“$”是什么意思</u> ：
- `#` 预编译，占位符，进行转义
- `$` 直接替换，不进行转义，**会有 sql 注入风险**

# ❤️ 分布式
雪花算法 ：分布式唯一 ID，是递增的 64 位整数 ID。通过时间戳、数据中心 ID、机器 ID 和序列号的组合

# ❤️ 并发
<u>进程与线程</u> ：
- 进程是程序的一次独立运行。当你打开一个浏览器和一个文档编辑器，它们就是两个独立的进程，有各自的内存空间，彼此之间不会干扰
- 线程是进程中的一个执行单元。在一个浏览器进程中，可能会有多个线程：一个线程负责加载网页，一个线程负责处理用户输入，一个线程负责网络请求。这些线程共享着浏览器的内存，但又各自独立运行

<u>Java 中如何确保线程安全</u> ：
- synchronized
- volatile
- Atomic
- 并发集合 ConcurrentHashMap ……
- 使用 `Collections.synchronizedList` 、`Collections.synchronizedMap` 方法来包装集合，将集合改为线程安全版本

<u>Java 中规定的线程的状态有哪几种</u> ：
- NEW ：线程被创建但尚未启动。比如调用 `new Thread()` 后，但尚未调用 `start()`
- RUNNABLE ：线程正在运行或准备运行的状态
	- 就绪状态：线程已经获取了 CPU 时间片，但尚未开始执行
	- 运行状态：线程正在 CPU 上执行
- BLOCKED ：线程因为竞争锁而被阻塞的状态。比如线程试图进入一个被其他线程占用的 synchronized 块
- WAITING ：线程进入等待状态，直到被其他线程唤醒。比如调用 Object.wait()、Thread.join() 或 LockSupport.park()
- TIMED_WAITING ：线程进入等待状态，但有一个超时时间。比如调用 Thread.sleep()、Object.wait(long timeout)、Thread.join(long millis) 或 LockSupport.parkNanos()
- TERMINATED ：线程已经结束的状态。比如线程的 run() 方法执行完成，或者因为异常而终止

<u>新建线程有几种方法</u> ：
- 继承 Thread 类 ：不推荐，因为 java 是单继承
- Runnable、Callable ：推荐
- 使用线程池 ：推荐

✅ 线程数的设置 ：
- CPU 密集型（视频编解码、科学计算、加密、图像处理 ……）：线程数 ≈ CPU 核心数。因为线程是不会阻塞的一直占用 CPU 核心数在工作
- IO 密集型（数据库操作、网络请求、文件读取）：线程数 ≈ CPU核心数 × 2 ～ 4。IO 操作时线程会阻塞，CPU 核心会处于空闲，所以可以适当增加线程数来提高 CPU 的利用率
- 混合型（计算 + IO）：用线程池 + 压测工具（如 JMeter、wrk）动态测试吞吐量


✅ 线程运行完之后是什么状态

# ❤️ JVM
<u>运行时数据区是 JVM 的内存结构，用于存储程序运行时的各种数据。包括以下几个部分</u>
- 程序计数器 ：存储当前线程正在执行的字节码指令的地址
- Java 虚拟机栈 ：存储方法的局部变量表、操作数栈、动态链接、方法出口等信息
- 本地方法栈 ：为本地方法服务，存储本地方法的调用和相关数据
- 堆 ：存储对象实例和数组
- 方法区 ：存储类的信息、常量、静态变量、即时编译后的代码 ……

<u>深拷贝和浅拷贝的区别</u> ：
- 对于基本数据类型，两者均会拷贝
- 对于对象中实例对象的引用，浅拷贝是拷贝实例对象的引用地址，即浅拷贝出来的新对象的实例对象域指向的仍是旧对象；深拷贝会把实例对象引用地址所指向的对象也复制，即深拷贝的新对象实例对象的引用和旧对象的实例对象的引用指向不是同一个对象

# ❤️ 计算机网络
<u>三次握手</u>：若在握手过程中某个阶段莫名中断，会再次以相同的顺序发送相同的数据包
- 第一次握手：发送端首先发送一个带 SYN【~~synchronize~~】标志的数据包给对方；
- 第二次握手：接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息；
- 第三次握手：发送端再回传一个带 ACK【~~acknowledgement~~】标志的数据包，代表握手结束；

# ❤️ 操作系统


# ❤️ 中间件
## 💛 Redis
Redis 备份 ：[[💻 计算机/🛢️ 数据库/Redis/3-1 高级#❤️ 持久化|持久化]]


## 💛 Kafka
<u>默认的分区策略</u> ：
- `如果 ProducerRecord 指定了 Partition` ：则发送消息到指定分区
- `如果 ProducerRecord 没有指定 Partition` 
	- `指定了 key` ：根据 key 求 hash 值，然后将 hash 值对 partition 数量取模。【~~由于要保证同一个 key 会被映射到同一 Partition 上，所以在对 Partition 的数量取模时，这个数量是所有的 Partition 的数量，而不是可用的 Partition 的数量~~，~~但是这又会导致另一个问题，如果分配给消息的分区是不可用的，那就会失败，需要生产者使用一些机制来处理~~】
	- `没有指定 key` ：每隔一段时间，随机选择一个 partition。在某个时间段内的所有消息都发送到这个 partition，如果发送出错，那就重新选择一个 partition

## ShardingSphere
- 同一条业务数据最好采用同一个分片 id，否则可能出现跨库事务、跨库查询 ……

# ❤️ Docker
✅ Docker 相比 jar 包的优势，为什么不用 jar 包
- docker 确保了开发环境 = 生产环境，jar 包的运行比较依赖于宿主机的环境
- docker 镜像是有存储的，如果新版本有问题，我可以立马回退版本
- docker 容器之间相互隔离，文件系统独立，减少了相互影响的风险

# ❤️ Linux
<u>df 、du</u> ：
- `df` disk free 用于显示文件系统的磁盘空间使用情况
- `du` disk usage 用于显示目录或文件占用的磁盘空间大小

<u>信号</u> ：

# ❤️ 线上问题排查
✅ 某个事务方法中执行数据库的操作部分生效 ：该方法中有两个写库操作，其中一个成功了，那说明不可能是报错了，如果报错肯定回滚了，说明没执行肯定是逻辑没走到
